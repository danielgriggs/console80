import os
import pygame
import pygame.gfxdraw
import math
import logging

# Todo
# Add cover layer
# Add rotation.
# Add more marks
# Add offset dial type. - done
# Digital display!
# Segmented LED style display.


class MainScreen:
    screen = None;
    
    def __init__(self, hw=False):
        "Ininitializes a new pygame screen using the framebuffer"
        # Based on "Python GUI in Linux frame buffer"
        # http://www.karoltomala.com/blog/?p=679
        disp_no = os.getenv("DISPLAY")
        if disp_no:
            logging.info("I'm running under X display = {0}".format(disp_no))
        
        # Check which frame buffer drivers are available
        # Start with fbcon since directfb hangs with composite output
        drivers = ['fbcon', 'directfb', 'svgalib']
        found = False
        for driver in drivers:
            os.putenv('SDL_FBDEV', '/dev/fb0')
            os.putenv('SDL_NOMOUSE', '1')
            # Make sure that SDL_VIDEODRIVER is set
            if not os.getenv('SDL_VIDEODRIVER'):
                os.putenv('SDL_VIDEODRIVER', driver)
            try:
                pygame.display.init()
            except pygame.error:
                logging.critical('Driver: {0} failed.'.format(driver))
                continue
            found = True
            break
    
        if not found:
            raise Exception('No suitable video driver found!')

        # Find the size of the screen.
        size = (pygame.display.Info().current_w, pygame.display.Info().current_h)
        self.size = size
        logging.info("Framebuffer size: %d x %d" % (size[0], size[1]))

        # Figure out what flags for initialisation are.
        flags = pygame.FULLSCREEN
        if hw is True:
            flags |= pygame.HWSURFACE

        # Create a surface.
        self.screen = pygame.display.set_mode(size, flags)
        # Initialise a font?
        pygame.font.init()

        # Setup basic colours and borders.
        self.screenBgColour = (0,0,0)
        self.wScreenBorderWidth = 5
        self.wScreenBgColour = (50,50,50)

        # Clear the screen to start
        self.screen.fill(self.screenBgColour)
        # Store the Working Window Size.
        self.wSize = (size[0] - (self.wScreenBorderWidth*2),
                      size[1] - (self.wScreenBorderWidth*2))
        # Generate a working screen.
        self.wScreen = self.screen.subsurface((self.wScreenBorderWidth,
                                               self.wScreenBorderWidth,
                                               self.wSize[0],
                                               self.wSize[1]))
        # Fill it with a colour!
        self.wScreen.fill(self.wScreenBgColour)

        # Render the screen
        pygame.display.update()

    def __del__(self):
        "Destructor to make sure pygame shuts down, etc."

    def createClock(self):
        return pygame.time.Clock()

    def redrawScreen(self):
        pygame.display.flip()

    def autoLayoutPanels(self,panels=(4,3),label=0):
        "Figure out dimensions for how big the panels are and generates and array of panels."
        "Takes a simple tuple of columns by rows."

        # calculate maximum column width.
        columnSize = self.wSize[0] / float(panels[0])
        logging.debug("Column size is {} / {} = {}".format(self.wSize[0],panels[0],columnSize))
        rowSize = int ( self.wSize[1] / float(panels[1]) )
        logging.debug("Row size is {} / {} = {}".format(self.wSize[1],panels[1],rowSize))

        # We need the smaller of the two
        maxSize = columnSize
        vMaxSize = maxSize
        if columnSize > rowSize:
            maxSize = int( rowSize * ( 1.00 / (1.00 + label) ) )
            vMaxSize = rowSize

        maxSize -= 1
        # So size is now maxSize by maxSize, figure out offsets.
        # Also make the maxSize divisiable by two.
        halfwidth = math.floor(maxSize / 2)
        maxSize = int ( halfwidth * 2 )
        logging.debug("choosen maxSize of side is {}".format(maxSize))

        # Centre offset is the left over pixels divided by the numbers of panels + 1
        XOffSet = int( ( self.wSize[0] - (panels[0] * maxSize) ) / float( panels[0] + 1 ) ) + maxSize
        YOffSet = int( ( self.wSize[1] - (panels[1] * vMaxSize) ) / float( panels[1] + 1 ) ) + vMaxSize
        logging.debug("Offsets are X:{} Y:{}".format(XOffSet,YOffSet))

        # create an array for panels.
        panelPositions = []
        for y in xrange(panels[1],0,-1):
            for x in xrange(1,panels[0]+1,1):
                xPos = int( XOffSet * x ) - maxSize
                yPos = int( YOffSet * y ) - vMaxSize
                logging.debug("int( {} * {} ) - {} = {}".format(XOffSet,x,halfwidth,xPos))
                panelPositions.append({ "rect" : (xPos, yPos, maxSize, maxSize), "rpos" : (x, y)})
        return panelPositions

class GenericPanel():
    def __init__(self,screen,rect,label=0):
        "Ininitializes basic panel data"
        # Store a reference to the screen.
        self.screen = screen
        self.rect = rect
        # Label Settings
        self.boxLabelSize = label
        self.boxLabelText = "No Label"
        self.boxLabelColour = (0,0,0)
        self.boxLabelBorderWidth = 0
        self.boxLabelBorderColour = (255,255,255)
        self.boxLabelBgColour = (50,50,50)
        # Box settings
        self.boxBorderWidth = 1
        self.boxBorderColour = (255,255,255)
        self.boxBgColour = (100,100,100)
        self.boxName = "GenericPanel"
        
        # Generate a subsurface for this panel..
        self.panel = self.screen.subsurface(rect)
        
        # Generate a subsurface for the label.
        if self.boxLabelSize > 0:
            labelRect = pygame.Rect(rect[0],
                                    rect[1]+rect[3],
                                    rect[2],
                                    int ( math.floor(rect[3] * label)) - 1)
            logging.debug("Screen Size: {}".format(self.screen))
            logging.debug("Box Size: {}".format(rect))
            logging.debug("Label Size: {}".format(labelRect))
            self.panelLabel = self.screen.subsurface(labelRect)
            self.panelLabel.fill(self.boxLabelColour)
            if self.boxLabelBorderWidth > 0:
                pygame.draw.rect(self.panelLabel,
                                 self.boxLabelBorderColour,
                                 self.panelLabel.get_rect(),
                                 self.boxLabelBorderWidth)

        self.panelSize = self.panel.get_size()
        self._draw_background()
        self._draw_label()

    def _draw_background(self):
        "Internal method for regenerating the background"
        # Fill up the background with a colour.
        self.panel.fill(self.boxBgColour)
        # Border width is centered, needs
        # border width/2 offset
        if self.boxBorderWidth > 0:
            pygame.draw.rect(self.panel,
                             self.boxBorderColour,
                             self.panel.get_rect(),
                             self.boxBorderWidth)

    def _draw_label(self):
        if self.boxLabelSize > 0:
            # Fill the label with background colour
            self.panelLabel.fill(self.boxLabelBgColour)
            # render a box with text.
            labelFont = pygame.font.Font(None, 48)
            Text = labelFont.render(self.boxLabelText, 1, (255,255,255), self.boxLabelBgColour)
            
            # Convert to display format (faster, also allows scaling)
            Text = Text.convert()
            Text.set_colorkey(self.boxLabelBgColour)
            textRect = Text.get_rect()
            
            # Get the Label size
            panelLabelRect = self.panelLabel.get_rect()
            
            # Scale it inside
            scaledSize = textRect.fit(panelLabelRect)
            
            # transform and copy.
            scaledText = pygame.transform.smoothscale(Text,scaledSize.size)
            self.panelLabel.blit(scaledText,scaledSize)
        
    def setBGColour(self,colour):
        self.boxBgColour = colour
        self._draw_background()
        
    def setBorderColour(self,colour):
        self.boxBorderColour = colour
        self._draw_background()
        
    def setBorderWidth(self,width):
        self.boxBorderWidth = width
        self._draw_background()

    def setLabelText(self,text):
        self.boxLabelText = text
        self._draw_label()        

    def setName(self,text):
        self.boxName = text
        
    def getName(self):
        return self.boxName

    def addDial(self):
        self.dial = DialIndicator(self.panel)
        self.dial.Draw()
        
    def addBar(self):
        self.dial = BarIndicator(self.panel)
        self.dial.Draw()
        
class GenericIndicator(object):
    def __init__(self,surface):
        "Ininitializes basic panel data"
        # Store a reference to the screen.
        self.surface = surface
        # Set up the box.
        self.boxPosition = (0,0)
        self.boxSize = surface.get_size()
        self.boxBorderWidth = 2
        self.boxBorderColour = (255,255,255)
        self.boxBgColour = (0,0,0)
        # Store generic values.
        self.value = 0
        self.valueHistory = []
        self.maxHistory = 5
        self.maxValue = 100
        self.minValue = 0
        # Initialise bits and bobs.
        # self._initBackGround()

    def _initBackGround(self):
        self.background = pygame.Surface(self.boxSize)
        self.background = self.background.convert_alpha()
        # print "{:#x}".format(self.background.get_flags())
        
    def setPosition(self,position):
        "Accept new position as (x,y)"
        self.boxPosition = position
        
    def setValue(self,value):
        # Record current value to history
        self.valueHistory.append(self.value)
        # Record new value
        self.value = value
        # Clear history
        while len(self.valueHistory) > self.maxHistory:
            self.valueHistory.pop(0)
        self.Draw()

    def setSize(self,size):
        "Accept new size as (x,y)"
        self.boxSize = size
        # re-initialise background size
        self._initBackGround()
        
    def getValue(self):
        "Return the current clipped value"
        if self.value > self.maxValue:
            return self.maxValue
        elif self.value < self.minValue:
            return self.minValue
        else:
            return self.value

class GenericBiIndicator(object):
    def __init__(self,screen):
        "Ininitializes basic panel data"
        # Store a reference to the screen.
        self.screen = screen
        # Set up the box.
        self.boxPosition = (0,0)
        self.boxSize = (80,80)
        self.boxBorderWidth = 2
        self.boxBorderColour = (255,255,255,255)
        self.boxBgColour = (0,0,0,255)
        # Store co-ordinate values.
        self.value = (0,0)
        self.valueHistory = []
        self.maxHistory = 5
        # Min, Max       X  ,Y
        self.maxValue = (100,100)
        self.minValue = (0  ,0)

    def _initBackGround(self):
        self.background = pygame.Surface(self.boxSize)
        self.background.convert(self.screen)

    def setPosition(self,position):
        "Accept new position as (x,y)"
        self.boxPosition = position
        
    def setValue(self,value):
        "This must be a (x,y) Tuple"
        # Should be a co-ordinate. (x,y)
        if not isinstance(value, tuple) or len(value) != 2:
            raise TypeError("This should be co-ordinates")
        # Record to history
        self.valueHistory.append(self.value)
        # Record new value
        self.value = value
        # Clean up the history
        while len(self.valueHistory) > self.maxHistory:
            self.valueHistory.pop(0)

    def getValue(self):
        "Return the current clipped value"
        value = ['','']
        for i in (0, 1):
            if self.value[i] > self.maxValue[i]:
                value[i] = self.maxValue[i]
            elif self.value[i] < self.minValue[i]:
                value[i] = self.maxValue[i]
            else:
                value[i] = self.value[i]
                
        return value

    def setSize(self,size):
        "Accept new size as (x,y)"
        self.boxSize = size
        # re-initialise background size
        self._initBackGround()


class ScatterIndicator(GenericBiIndicator):
    "Scatter Graph for lack of a better name"
    def __init__(self,screen):
        super(ScatterIndicator,self).__init__(screen)
        "Ininitializes a new BarGraph"
        # axisZero for   X,Y
        self.axisZero   = (50,50)
        self.axisWidth  = 1
        self.axisColour = (255,255,255)
        self.pointColour  = (0,255,0)
        self.pointRadius  = 5
        self.pointOutline = 1
        self.maxValue = (100,100)
        self.minValue = (  0,  0)
        self.boxBorderWidth = 0
        # Initialise bits and bobs.
        self._initBackGround()

    def _initBackGround(self):
        super(ScatterIndicator, self)._initBackGround()
        # Draw outside box.
        if self.boxBorderWidth > 0:
            pygame.draw.rect(self.background, self.boxBorderColour, ((0,0),self.boxSize), self.boxBorderWidth)

        # Draw the X Axis, at the Y 
        maxYRange = self.maxValue[1] - self.minValue[1]
        # The Y part of the graph needs flipping
        normZeroOnY = maxYRange - ( self.axisZero[1] - self.minValue[1] )
#        normZeroOnY = self.axisZero[1] - self.minValue[1]
        logging.debug("axisZero[1] = {} self.minValue[1] = {}".format(self.axisZero[1],self.minValue[1]))
        logging.debug("boxSize[Y] {} maxYRange {} normZeroOnY {}".format(self.boxSize[0], maxYRange, normZeroOnY))
        scaledXZero = int( self.boxSize[1] * ( normZeroOnY / float(maxYRange) ) ) - 1
        logging.debug("  Draw from {},{} to {},{}".format(0                ,scaledXZero,
                                                  self.boxSize[0]-1,scaledXZero))
        pygame.draw.line(self.background,
                         self.axisColour,
                         (0                ,scaledXZero),
                         (self.boxSize[0]-1,scaledXZero),
                         self.axisWidth)

        # Draw the Y Zero
        maxXRange   = self.maxValue[0] - self.minValue[0]
        normZeroOnX = self.axisZero[0] - self.minValue[0]
        logging.debug("boxSize[X] {} maxRangeY {} normZeroY {}".format(self.boxSize[1], maxXRange, normZeroOnX))
        scaledYZero = int( self.boxSize[0] * ( normZeroOnX / float(maxXRange) ) ) - 1
        logging.debug("  Draw from {},{} to {},{}".format(scaledYZero, 0,
                                                  scaledYZero, self.boxSize[1]-1))
        pygame.draw.line(self.background,
                         self.axisColour,
                         (scaledYZero, 0),
                         (scaledYZero, self.boxSize[1]-1),
                         self.axisWidth)

    def Draw(self):
        panel = self.background.copy()
        value = self.getValue()
        
        maxYRange = self.maxValue[1] - self.minValue[1]
        # The Y part of the graph needs flipping
        normValueOnY = maxYRange - ( value[1] - self.minValue[1] )
        scaledY = int( self.boxSize[1] * ( normValueOnY / float(maxYRange) ) )
        
        # Calculate X value
        maxXRange = self.maxValue[0] - self.minValue[0]
        normValueOnX = value[0] - self.minValue[0]
        scaledX = int( self.boxSize[0] * ( normValueOnX / float(maxXRange) ) )

        pygame.draw.circle(panel,
                           self.pointColour, # Colour
                           (scaledX,scaledY), # Circle Centre
                           5, # Radius
                           1) # line width Zero for fill
        self.screen.blit(panel,self.boxPosition)

        
class BarIndicator(GenericIndicator):
    "Bar graph data"
    def __init__(self,screen):
        "Ininitializes a new BarGraph"
        GenericIndicator.__init__(self,screen)
        self.barPadding = 5
        self.barColour = (0,255,0)

    def _initBackGround(self):
        GenericIndicator._initBackGround(self)
        # Draw outside box.
        pygame.draw.rect(self.background,
                         self.boxBorderColour,
                         ((0,0),self.boxSize),
                         self.boxBorderWidth)
        
    def Draw(self):
        if not hasattr(self, 'background'):
            self._initBackGround()
        panel = self.background.copy()
        # Figure out bar size and off set
        barOff = self.barPadding
        maxBarSize = ( self.boxSize[0] - barOff * 2, self.boxSize[1] - barOff * 2 )
        # Scale value to final size.
        barHeight = int ( maxBarSize[1] * ( self.getValue() / float(100) ) )
        
        logging.debug("Bar Total Value {:03}, Scaled {}".format(self.value,barHeight))
        # Calculate bar details Top and Left
        barPosition = ( barOff, barOff )
        barSize = ( self.boxSize[0] - barOff * 2, barHeight )
        # Now draw a box
        pygame.draw.rect(panel, self.barColour, (barPosition , barSize), 0)
        tPanel = pygame.transform.flip(panel,False,True)
        self.surface.blit(tPanel,self.boxPosition)


class DialIndicator(GenericIndicator):
    "Dial Graph is a thing apparently"
    def __init__(self,screen,offsetStyle=False):
        "Ininitializes a new Dial"
        GenericIndicator.__init__(self,screen)
        self.boxBorderWidth = 0
        self.dialArmColour = (0,255,0,255)
        self.offsetStyle = offsetStyle
        self.dialStart = -135
        self.dialSweep = 270
        if offsetStyle is True:
            self.dialStart = -30
            self.dialSweep = 60
        
    def _initBackGround(self):
        "Draw Bacground"
        GenericIndicator._initBackGround(self)
        # Try and make a transparent background.
        self.background.fill((0,0,0,0))
        # Draw a background
        minWidth = self.boxSize[0]
        if minWidth > self.boxSize[1]:
            minWidth = self.boxSize[1]
        self.radius = int( math.floor( float( minWidth ) / 2 ) ) - 1
        self.circleCentre = (self.radius, self.radius)
        
        if self.offsetStyle is True:
            self.dialCentre = (self.radius, int( self.radius * 0.2))
            self.dialLength = int( float(self.radius) * 1.4 )
        else:
            self.dialCentre = self.circleCentre
            self.dialLength = int( float(self.radius) * 0.8 )

        print("Setup Centre {}, Radius {}".format(self.circleCentre,self.radius))
        print("Setup dialCentre {}, dialLength {}".format(self.dialCentre,self.dialLength))
        
        # Draw the background of the Dial
        pygame.gfxdraw.filled_circle(self.background,
                                     self.circleCentre[0],
                                     self.circleCentre[1],
                                     self.radius,
                                     self.boxBgColour)

        # Draw the border thicker as required.
        for i in xrange(self.boxBorderWidth):
            pygame.gfxdraw.aacircle(self.background,
                                    self.circleCentre[0],
                                    self.circleCentre[1],
                                    self.radius-i,
                                    self.boxBorderColour)
            
        dialZeroAngleRad  = math.radians(self.dialStart)
        dialMaxAngleRad  = math.radians(self.dialStart + self.dialSweep)
        

    def Draw(self):
        if not hasattr(self, 'background'):
            self._initBackGround()
        panel = self.background.copy()
        # Draw new line
        # print "Rad {} Length {}".format(self.radius,self.dialLength)
        dialAngle  = (( self.getValue() / float(100) ) * self.dialSweep ) + self.dialStart
        dialAngleRad  = math.radians(dialAngle)
        deltaX = int( self.dialLength * math.sin(dialAngleRad) )
        deltaY = int( self.dialLength * math.cos(dialAngleRad) )
        dialEnd = ( self.dialCentre[0] + deltaX, self.dialCentre[1] + deltaY )
        pygame.draw.line(panel,
                         self.dialArmColour,
                         self.dialCentre,
                         dialEnd,
                         2)
        logging.debug("Dial Value {:03}, Angle {}, X,Y {},{}".format(self.value,dialAngle,deltaX,deltaY))
        tPanel = pygame.transform.flip(panel,False,True)
        self.surface.blit(tPanel,self.boxPosition)
        





        
